<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Video Chat">
<title>üìû Video Chat iOS Optimized</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
* { 
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}
body {
    font-family: 'Comic Sans MS', Arial, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    color: #333;
    /* Verhindert Pull-to-Refresh auf Mobile */
    overscroll-behavior-y: contain;
}
.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 15px;
}
/* Contact Grid */
.contacts-section {
    background: white;
    padding: 15px;
    border-radius: 15px;
    margin-bottom: 15px;
}
.contact-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 10px;
}
.contact-card {
    background: #e5e7eb;
    border: 3px solid #9ca3af;
    border-radius: 12px;
    padding: 15px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
    min-height: 100px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    /* Fix f√ºr Mobile Tap Highlight */
    -webkit-tap-highlight-color: transparent;
}
.contact-card.me {
    background: #dbeafe;
    border-color: #3b82f6;
    cursor: default;
}
.contact-card.empty {
    background: #f3f4f6;
    border-color: #d1d5db;
    cursor: default;
}
.contact-card.offline {
    background: #e5e7eb;
    border-color: #9ca3af;
    cursor: default;
    opacity: 0.7;
}
.contact-card.online {
    background: #d1fae5;
    border-color: #22c55e;
}
.contact-card.calling {
    background: #fecaca;
    border-color: #ef4444;
    animation: pulse 1s infinite;
}
@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}
.contact-emoji {
    font-size: 2.5em;
    margin-bottom: 5px;
}
.contact-name {
    font-size: 1.1em;
    font-weight: bold;
    word-break: break-all;
}
.contact-label {
    font-size: 0.8em;
    color: #6b7280;
    margin-top: 3px;
}
/* Video Section */
.video-section {
    background: white;
    padding: 15px;
    border-radius: 15px;
    margin-bottom: 15px;
}
.video-grid {
    display: grid;
    gap: 10px;
}
.video-box {
    background: #1a1a1a;
    border-radius: 12px;
    overflow: hidden;
    position: relative;
    aspect-ratio: 3/4; /* Besseres Format f√ºr Mobile */
}
.video-box video {
    width: 100%;
    height: 100%;
    object-fit: cover; /* F√ºllt die Box komplett aus */
    display: block;
    background: #000;
}
.video-label {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.6);
    color: white;
    padding: 5px 10px;
    border-radius: 8px;
    font-weight: bold;
    z-index: 50;
    font-size: 0.9em;
}
/* Buttons */
.btn {
    width: 100%;
    padding: 15px;
    border: none;
    border-radius: 10px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    font-family: inherit;
    margin: 8px 0;
    -webkit-tap-highlight-color: transparent;
}
.btn-primary {
    background: linear-gradient(135deg, #60a5fa, #3b82f6);
    color: white;
}
/* Call Overlay */
.call-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.95);
    justify-content: center;
    align-items: center;
    z-index: 2000;
}
.call-overlay.active {
    display: flex;
}
.call-dialog {
    text-align: center;
    color: white;
}
.call-dialog .avatar {
    width: 120px;
    height: 120px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    border-radius: 50%;
    margin: 0 auto 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 4em;
    animation: ring 1s infinite;
}
@keyframes ring {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}
.call-dialog .caller-name {
    font-size: 2em;
    font-weight: bold;
    margin: 20px 0;
}
.call-dialog .call-status {
    font-size: 1.2em;
    color: #9ca3af;
    margin-bottom: 40px;
}
.call-actions {
    display: flex;
    gap: 30px;
    justify-content: center;
}
.call-btn {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: none;
    font-size: 2em;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
}
.call-btn.accept {
    background: #22c55e;
}
.call-btn.reject {
    background: #ef4444;
}
/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    justify-content: center;
    align-items: center;
    z-index: 1000;
    padding: 20px;
}
.modal.active {
    display: flex;
}
.modal-content {
    background: white;
    padding: 25px;
    border-radius: 15px;
    max-width: 500px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
}
.modal-content h2 {
    margin-bottom: 20px;
    color: #667eea;
}
.input-group {
    margin: 15px 0;
}
.input-group label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
    color: #374151;
}
.input-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid #d1d5db;
    border-radius: 8px;
    font-size: 1em;
}
.btn-save {
    background: linear-gradient(135deg, #4ade80, #22c55e);
    color: white;
}
.btn-cancel {
    background: linear-gradient(135deg, #9ca3af, #6b7280);
    color: white;
}
/* Setup Screen */
.setup-screen {
    background: white;
    padding: 30px;
    border-radius: 15px;
    text-align: center;
}
.setup-screen h1 {
    color: #667eea;
    margin-bottom: 20px;
}
.setup-screen .emoji {
    font-size: 5em;
    margin: 20px 0;
}
.screen {
    display: none;
}
.screen.active {
    display: block;
}
@media (min-width: 768px) {
    .video-grid.two-videos {
        grid-template-columns: repeat(2, 1fr);
    }
    .video-box {
        aspect-ratio: 16/9;
    }
}
@media (max-width: 480px) {
    .contact-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    .contact-emoji {
        font-size: 2em;
    }
    .contact-name {
        font-size: 0.95em;
    }
}
</style>
</head>
<body>

<div class="screen active" id="setupScreen">
    <div class="container">
        <div class="setup-screen">
            <div class="emoji">üëã</div>
            <h1>Video Chat starten</h1>
            <div class="input-group">
                <label>Dein Name:</label>
                <input type="text" id="setupMyName" placeholder="z.B. anna-2026">
            </div>
            <button class="btn btn-save" onclick="startApp()">Los geht's! üöÄ</button>
        </div>
    </div>
</div>

<div class="call-overlay" id="incomingCallOverlay">
    <div class="call-dialog">
        <div class="avatar">
            <span>üìû</span>
        </div>
        <div class="caller-name" id="incomingCallerName"></div>
        <div class="call-status">Eingehender Videoanruf...</div>
        <div class="call-actions">
            <button class="call-btn reject" onclick="rejectIncomingCall()">‚úó</button>
            <button class="call-btn accept" onclick="acceptIncomingCall()">‚úì</button>
        </div>
    </div>
</div>

<div class="call-overlay" id="outgoingCallOverlay">
    <div class="call-dialog">
        <div class="avatar">
            <span>üìû</span>
        </div>
        <div class="caller-name" id="outgoingCallerName"></div>
        <div class="call-status">Rufe an...</div>
        <div class="call-actions">
            <button class="call-btn reject" onclick="cancelOutgoingCall()">‚úó</button>
        </div>
    </div>
</div>

<div class="screen" id="mainScreen">
    <div class="container">
        <div class="contacts-section" id="contactsSection">
            <div class="contact-grid">
                <div class="contact-card me">
                    <div class="contact-emoji">üòä</div>
                    <div class="contact-name" id="myContactName">Ich</div>
                    <div class="contact-label">Du</div>
                </div>
                <div class="contact-card empty" id="contact0" onclick="contactClick(0)">
                    <div class="contact-emoji">üò¥</div>
                    <div class="contact-name">leer</div>
                </div>
                <div class="contact-card empty" id="contact1" onclick="contactClick(1)">
                    <div class="contact-emoji">üò¥</div>
                    <div class="contact-name">leer</div>
                </div>
                <div class="contact-card empty" id="contact2" onclick="contactClick(2)">
                    <div class="contact-emoji">üò¥</div>
                    <div class="contact-name">leer</div>
                </div>
                <div class="contact-card empty" id="contact3" onclick="contactClick(3)">
                    <div class="contact-emoji">üò¥</div>
                    <div class="contact-name">leer</div>
                </div>
                <div class="contact-card empty" id="contact4" onclick="contactClick(4)">
                    <div class="contact-emoji">üò¥</div>
                    <div class="contact-name">leer</div>
                </div>
            </div>
        </div>

        <div class="video-section" id="videoSection">
            <div class="video-grid" id="videoGrid">
                <div class="video-box">
                    <video id="myVideo" autoplay muted playsinline webkit-playsinline></video>
                    <div class="video-label">Du</div>
                </div>
            </div>
        </div>

        <button class="btn btn-primary" onclick="openEditModal()">Kontakte bearbeiten ‚úèÔ∏è</button>
    </div>
</div>

<div class="modal" id="editModal">
    <div class="modal-content">
        <h2>‚úèÔ∏è Kontakte bearbeiten</h2>
        <div class="input-group">
            <label>Dein Name:</label>
            <input type="text" id="editMyName" placeholder="Dein Name">
        </div>
        <div class="input-group">
            <label>Kontakt 1:</label>
            <input type="text" id="editContact0" placeholder="leer">
        </div>
        <div class="input-group">
            <label>Kontakt 2:</label>
            <input type="text" id="editContact1" placeholder="leer">
        </div>
        <div class="input-group">
            <label>Kontakt 3:</label>
            <input type="text" id="editContact2" placeholder="leer">
        </div>
        <div class="input-group">
            <label>Kontakt 4:</label>
            <input type="text" id="editContact3" placeholder="leer">
        </div>
        <div class="input-group">
            <label>Kontakt 5:</label>
            <input type="text" id="editContact4" placeholder="leer">
        </div>
        <button class="btn btn-save" onclick="saveContacts()">Speichern</button>
        <button class="btn btn-cancel" onclick="closeEditModal()">Abbrechen</button>
    </div>
</div>

<script>
const STORAGE_MY_NAME = 'videochat_my_name';
const STORAGE_CONTACTS = 'videochat_contacts';

const CALL_STATE = {
    IDLE: 'idle',
    OUTGOING: 'outgoing',
    INCOMING: 'incoming',
    CONNECTED: 'connected'
};

let peer = null;
let myStream = null;
let myName = '';
let contacts = ['', '', '', '', ''];
let contactsOnlineStatus = [false, false, false, false, false];
let currentCall = null;
let callState = CALL_STATE.IDLE;
let activeContactIndex = -1;
let incomingCallObject = null;
let remoteAudioElement = null; // F√ºr Ton
let ringtoneAudio = null;
let remoteVideoElement = null; // F√ºr Bild
let onlineCheckInterval = null;
let isInBackground = false;
let notificationPermissionGranted = false;
let silentAudioContext = null;

function log(msg) {
    console.log('[VIDEO-CHAT]', msg);
}

// STILLES AUDIO IM HINTERGRUND
function createSilentAudio() {
    if (silentAudioContext) return;
    try {
        silentAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = silentAudioContext.createOscillator();
        const gainNode = silentAudioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(silentAudioContext.destination);
        oscillator.frequency.value = 20000;
        gainNode.gain.value = 0.001;
        oscillator.start();
        log('‚úì Silent Audio aktiv');
    } catch (e) {
        log('Silent Audio Error: ' + e);
    }
}

function stopSilentAudio() {
    if (silentAudioContext) {
        try {
            silentAudioContext.close();
        } catch(e) {}
        silentAudioContext = null;
    }
}

// BACKGROUND DETECTION
function setupBackgroundDetection() {
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            log('üì± App in Hintergrund');
            handleAppGoingBackground();
        } else {
            log('üëÅÔ∏è App wieder im Vordergrund');
            handleAppComingForeground();
        }
    });
    
    window.addEventListener('pagehide', handleAppGoingBackground);
    window.addEventListener('pageshow', handleAppComingForeground);
}

function handleAppGoingBackground() {
    if (isInBackground) return;
    isInBackground = true;
    
    // Kamera stoppen um "Orange Dot" zu entfernen
    if (callState === CALL_STATE.IDLE && myStream) {
        myStream.getTracks().forEach(track => track.stop());
        myStream = null;
    }
    createSilentAudio();
}

async function handleAppComingForeground() {
    if (!isInBackground) return;
    isInBackground = false;
    stopSilentAudio();
    
    // Stream neu anfordern
    if (!myStream && callState === CALL_STATE.IDLE) {
        try {
            await getMyStream();
        } catch (err) {
            log('Fehler beim Reaktivieren: ' + err.message);
        }
    }
}

async function getMyStream() {
    try {
        myStream = await navigator.mediaDevices.getUserMedia({ 
            video: {
                facingMode: 'user', // Frontkamera
                width: { ideal: 640 },
                height: { ideal: 480 }
            }, 
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            }
        });
        const myVideo = document.getElementById('myVideo');
        if (myVideo) {
            myVideo.srcObject = myStream;
            myVideo.play().catch(() => {});
        }
        return myStream;
    } catch (e) {
        console.error("Stream Error", e);
        throw e;
    }
}

// NOTIFICATIONS
async function requestNotificationPermission() {
    if (!('Notification' in window)) return false;
    if (Notification.permission === 'granted') {
        notificationPermissionGranted = true;
        return true;
    }
    if (Notification.permission !== 'denied') {
        const permission = await Notification.requestPermission();
        notificationPermissionGranted = permission === 'granted';
        return notificationPermissionGranted;
    }
    return false;
}

function showNotification(title, body) {
    if (!document.hidden || !notificationPermissionGranted) return;
    try {
        const notification = new Notification(title, {
            body: body,
            icon: 'üìû',
            badge: 'üìû',
            tag: 'videochat-call',
            vibrate: [300, 200, 300]
        });
        notification.onclick = () => { window.focus(); notification.close(); };
    } catch (e) { log('Notif Error: ' + e); }
}

// RESET
function fullStateReset() {
    log('üßπ State-Reset');
    if (currentCall) { try { currentCall.close(); } catch(e) {} currentCall = null; }
    if (incomingCallObject) { try { incomingCallObject.close(); } catch(e) {} incomingCallObject = null; }
    
    removeRemoteVideo();
    destroyAudioElement();
    stopRingtone();
    hideAllOverlays();
    
    callState = CALL_STATE.IDLE;
    activeContactIndex = -1;
    updateUI();
}

// ONLINE CHECK
function checkContactOnline(contactName, index) {
    if (!contactName || contactName.trim() === '' || !peer) {
        contactsOnlineStatus[index] = false;
        return Promise.resolve(false);
    }
    return new Promise((resolve) => {
        const timeout = setTimeout(() => {
            if (conn) try { conn.close(); } catch(e) {}
            contactsOnlineStatus[index] = false;
            resolve(false);
        }, 3000);
        
        let conn;
        try {
            conn = peer.connect(contactName, { reliable: false });
            conn.on('open', () => {
                clearTimeout(timeout);
                contactsOnlineStatus[index] = true;
                try { conn.close(); } catch(e) {}
                resolve(true);
            });
            conn.on('error', () => {
                clearTimeout(timeout);
                contactsOnlineStatus[index] = false;
                resolve(false);
            });
        } catch (e) {
            clearTimeout(timeout);
            contactsOnlineStatus[index] = false;
            resolve(false);
        }
    });
}

async function checkAllContactsOnline() {
    if (!peer || !peer.id) return;
    const checks = contacts.map((contact, index) => {
        if (contact && contact.trim() !== '') return checkContactOnline(contact, index);
        else return Promise.resolve(false);
    });
    await Promise.all(checks);
    updateUI();
}

function startOnlineCheck() {
    checkAllContactsOnline();
    if (onlineCheckInterval) clearInterval(onlineCheckInterval);
    onlineCheckInterval = setInterval(checkAllContactsOnline, 10000);
}

function stopOnlineCheck() {
    if (onlineCheckInterval) { clearInterval(onlineCheckInterval); onlineCheckInterval = null; }
}

// DATA STORAGE
function loadData() {
    const saved = localStorage.getItem(STORAGE_CONTACTS);
    if (saved) contacts = JSON.parse(saved);
    const savedName = localStorage.getItem(STORAGE_MY_NAME);
    if (savedName) myName = savedName;
}

function saveData() {
    localStorage.setItem(STORAGE_MY_NAME, myName);
    localStorage.setItem(STORAGE_CONTACTS, JSON.stringify(contacts));
}

// RINGTONE
function playRingtone() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;
        oscillator.start();
        ringtoneAudio = { oscillator, audioContext };
        setTimeout(() => stopRingtone(), 30000);
    } catch (e) { log('Ringtone error: ' + e); }
}

function stopRingtone() {
    if (ringtoneAudio) {
        try { 
            ringtoneAudio.oscillator.stop(); 
            ringtoneAudio.audioContext.close();
        } catch(e) {}
        ringtoneAudio = null;
    }
}

function hideAllOverlays() {
    const incoming = document.getElementById('incomingCallOverlay');
    const outgoing = document.getElementById('outgoingCallOverlay');
    if (incoming) { incoming.style.display = 'none'; incoming.classList.remove('active'); }
    if (outgoing) { outgoing.style.display = 'none'; outgoing.classList.remove('active'); }
}

// INIT
window.addEventListener('load', () => {
    loadData();
    if (myName && myName.trim() !== '') {
        document.getElementById('setupMyName').value = myName;
        setTimeout(autoStartApp, 500);
    }
});

async function autoStartApp() {
    try {
        await getMyStream();
        initializePeer();
        await requestNotificationPermission();
        setupBackgroundDetection();
        document.getElementById('setupScreen').classList.remove('active');
        document.getElementById('mainScreen').classList.add('active');
    } catch (err) {
        log('Auto-Start fehlgeschlagen: ' + err.message);
    }
}

async function startApp() {
    const name = document.getElementById('setupMyName').value.trim();
    if (!name || name.length < 3) { alert('Name zu kurz!'); return; }
    myName = name;
    saveData();
    try {
        await getMyStream();
        initializePeer();
        await requestNotificationPermission();
        setupBackgroundDetection();
        document.getElementById('setupScreen').classList.remove('active');
        document.getElementById('mainScreen').classList.add('active');
    } catch (err) {
        alert('Fehler: Zugriff auf Kamera verweigert!');
    }
}

function initializePeer() {
    peer = new Peer(myName);
    peer.on('open', (id) => {
        log('‚úì Peer online: ' + id);
        updateUI();
        startOnlineCheck();
    });
    peer.on('call', (call) => {
        handleIncomingCall(call);
    });
    peer.on('error', (err) => {
        if (err.type === 'unavailable-id') {
            alert('Name vergeben!');
            localStorage.removeItem(STORAGE_MY_NAME);
            location.reload();
        }
    });
}

function updateUI() {
    loadData();
    document.getElementById('myContactName').textContent = myName;
    contacts.forEach((contact, index) => {
        const card = document.getElementById('contact' + index);
        const nameDiv = card.querySelector('.contact-name');
        const emojiDiv = card.querySelector('.contact-emoji');
        card.classList.remove('empty', 'online', 'offline', 'calling');
        
        if (contact && contact.trim() !== '') {
            nameDiv.textContent = contact;
            if (callState === CALL_STATE.CONNECTED && activeContactIndex === index) {
                card.classList.add('calling');
                emojiDiv.textContent = 'üìû';
            } else if (contactsOnlineStatus[index]) {
                card.classList.add('online');
                emojiDiv.textContent = 'üòä';
            } else {
                card.classList.add('offline');
                emojiDiv.textContent = 'üò¥';
            }
        } else {
            nameDiv.textContent = 'leer';
            card.classList.add('empty');
            emojiDiv.textContent = 'üò¥';
        }
    });
}

function contactClick(index) {
    const contact = contacts[index];
    if (!contact || contact.trim() === '') return;
    
    if (!contactsOnlineStatus[index] && callState !== CALL_STATE.CONNECTED) {
        alert('Kontakt ist offline!');
        return;
    }
    
    if (callState === CALL_STATE.CONNECTED && activeContactIndex === index) {
        endCall();
    } else if (callState === CALL_STATE.IDLE) {
        startOutgoingCall(contact, index);
    }
}

// CALL LOGIC
function startOutgoingCall(contactName, index) {
    callState = CALL_STATE.OUTGOING;
    activeContactIndex = index;
    document.getElementById('outgoingCallerName').textContent = contactName;
    const overlay = document.getElementById('outgoingCallOverlay');
    overlay.style.display = 'flex';
    overlay.classList.add('active');
    
    currentCall = peer.call(contactName, myStream);
    if (!currentCall) {
        alert('Fehler beim Anruf!');
        fullStateReset();
        return;
    }
    
    currentCall.on('stream', (remoteStream) => {
        log('‚úì Outgoing Stream empfangen');
        hideAllOverlays();
        callState = CALL_STATE.CONNECTED;
        updateUI();
        addRemoteVideo(contactName, remoteStream);
    });
    
    currentCall.on('close', endCall);
    currentCall.on('error', (err) => { fullStateReset(); });
    
    setTimeout(() => {
        if (callState === CALL_STATE.OUTGOING) {
            cancelOutgoingCall();
            alert('Keine Antwort!');
        }
    }, 30000);
}

function cancelOutgoingCall() { fullStateReset(); }

async function handleIncomingCall(call) {
    const contactIndex = contacts.indexOf(call.peer);
    if (contactIndex === -1 && callState !== CALL_STATE.IDLE) return;
    
    if (!myStream) {
        try { await getMyStream(); } catch (err) { log('Stream Error Incoming: ' + err); }
    }
    
    showNotification('üìû Anruf!', 'Von: ' + call.peer);
    
    callState = CALL_STATE.INCOMING;
    activeContactIndex = contactIndex;
    incomingCallObject = call;
    document.getElementById('incomingCallerName').textContent = call.peer;
    
    const overlay = document.getElementById('incomingCallOverlay');
    overlay.style.display = 'flex';
    overlay.classList.add('active');
    playRingtone();
    
    setTimeout(() => {
        if (callState === CALL_STATE.INCOMING) rejectIncomingCall();
    }, 30000);
}

function acceptIncomingCall() {
    stopRingtone();
    
    // 1. Erst Overlay verstecken
    hideAllOverlays();
    
    // 2. Kleines Timeout f√ºr iOS Rendering Engine
    setTimeout(() => {
        if (!incomingCallObject) { fullStateReset(); return; }
        
        currentCall = incomingCallObject;
        incomingCallObject = null;
        
        currentCall.answer(myStream);
        
        callState = CALL_STATE.CONNECTED;
        updateUI();
        
        currentCall.on('stream', (remoteStream) => {
            log('‚úì Remote Stream (Incoming)');
            addRemoteVideo(currentCall.peer, remoteStream);
        });
        
        currentCall.on('close', endCall);
    }, 50); // 50ms Delay wichtig f√ºr Safari
}

function rejectIncomingCall() { fullStateReset(); }
function endCall() { fullStateReset(); setTimeout(checkAllContactsOnline, 1000); }

// ============================================================
// WICHTIGSTER TEIL: iOS SAFARI FIX F√úR REMOTE VIDEO
// ============================================================
function addRemoteVideo(name, stream) {
    log('F√ºge Video hinzu: ' + name);
    removeRemoteVideo();
    
    const grid = document.getElementById('videoGrid');
    grid.classList.add('two-videos');
    
    const box = document.createElement('div');
    box.className = 'video-box';
    box.id = 'remoteVideo';
    
    const video = document.createElement('video');
    video.id = 'remoteVideoElement';
    
    // 1. Attribute f√ºr iOS Inline Playback (Lowercase f√ºr HTML Attribut)
    video.setAttribute('playsinline', '');
    video.setAttribute('webkit-playsinline', '');
    
    // 2. JavaScript Property (CamelCase wichtig!)
    video.playsInline = true;
    
    // 3. Autoplay aktivieren
    video.autoplay = true;
    
    // 4. CRITICAL FIX: Video Muted setzen! 
    // Safari spielt Autoplay-Videos nur ab, wenn sie stumm sind.
    // Der Ton kommt √ºber das separate Audio-Element unten.
    video.muted = true;
    
    video.srcObject = stream;
    
    const label = document.createElement('div');
    label.className = 'video-label';
    label.textContent = name;
    
    box.appendChild(video);
    box.appendChild(label);
    grid.appendChild(box);
    
    remoteVideoElement = video;
    
    // 5. Separates Audio f√ºr den Ton
    createAudioElement(stream);
    
    // 6. Play erzwingen mit Promise-Handling
    const playPromise = video.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            log('Auto-Play Error: ' + error);
            // Fallback
            video.muted = true;
            video.play();
        });
    }
}

function createAudioElement(stream) {
    destroyAudioElement();
    // Separates Audio-Objekt f√ºr den Ton (unmuted)
    remoteAudioElement = document.createElement('audio');
    remoteAudioElement.autoplay = true;
    remoteAudioElement.srcObject = stream;
    remoteAudioElement.volume = 1.0;
    // Audio muss nicht ins DOM, um zu spielen, aber wir speichern Referenz
    document.body.appendChild(remoteAudioElement); 
    remoteAudioElement.play().catch(e => log('Audio Play Error: ' + e));
}

function destroyAudioElement() {
    if (remoteAudioElement) {
        try {
            remoteAudioElement.pause();
            remoteAudioElement.srcObject = null;
            if (remoteAudioElement.parentNode) remoteAudioElement.parentNode.removeChild(remoteAudioElement);
        } catch(e) {}
        remoteAudioElement = null;
    }
}

function removeRemoteVideo() {
    const remote = document.getElementById('remoteVideo');
    if (remote) {
        const video = remote.querySelector('video');
        if (video) {
            try { video.pause(); video.srcObject = null; } catch(e) {}
        }
        remote.remove();
    }
    remoteVideoElement = null;
    document.getElementById('videoGrid').classList.remove('two-videos');
}

// MODAL & CLEANUP
function openEditModal() {
    loadData();
    document.getElementById('editMyName').value = myName;
    contacts.forEach((contact, index) => {
        document.getElementById('editContact' + index).value = contact;
    });
    document.getElementById('editModal').classList.add('active');
}

function closeEditModal() { document.getElementById('editModal').classList.remove('active'); }

function saveContacts() {
    const newMyName = document.getElementById('editMyName').value.trim();
    if (!newMyName || newMyName.length < 3) { alert('Name zu kurz!'); return; }
    if (newMyName !== myName) {
        myName = newMyName;
        saveData();
        location.reload();
        return;
    }
    for (let i = 0; i < 5; i++) {
        contacts[i] = document.getElementById('editContact' + i).value.trim();
    }
    saveData();
    updateUI();
    closeEditModal();
    checkAllContactsOnline();
}

window.addEventListener('beforeunload', () => {
    stopOnlineCheck();
    stopSilentAudio();
    if (myStream) myStream.getTracks().forEach(track => track.stop());
    if (peer) peer.destroy();
    stopRingtone();
    destroyAudioElement();
});
</script>
</body>
</html>
